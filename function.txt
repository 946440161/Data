内置函数
Python解释器内置了许多函数和类型，这些函数和类型总是可用的。它们按字母顺序排列在这里。

内置函数		
abs()	delattr()	hash()	memoryview()	set()
all()	dict()	help()	min()	setattr()
any()	dir()	hex()	next()	slice()
ascii()	divmod()	id()	object()	sorted()
bin()	enumerate()	input()	oct()	staticmethod()
bool()	eval()	int()	open()	str()
breakpoint()	exec()	isinstance()	ord()	sum()
bytearray()	filter()	issubclass()	pow()	super()
bytes()	float()	iter()	print()	tuple()
callable()	format()	len()	property()	type()
chr()	frozenset()	list()	range()	vars()
classmethod()	getattr()	locals()	repr()	zip()
compile()	globals()	map()	reversed()	__import__()
complex()	hasattr()	max()	round()	 
abs(x)
返回数字的绝对值。参数可以是整数，也可以是浮点数。如果参数是复数，则返回其大小。

all(可迭代)
回归True如果可迭代是真(或者如果迭代是空的)。相当于：

def all(iterable):
    for element in iterable:
        if not element:
            return False
    return True
any(可迭代)
回归True如果可迭代是真的。如果可迭代为空，则返回False。相当于：

def any(iterable):
    for element in iterable:
        if element:
            return True
    return False
ascii(对象)
如repr()，返回包含对象的可打印表示形式的字符串，但转义返回的字符串中的非ASCII字符。repr()使用\x, \u或\U逃跑了。这将生成一个类似于repr()在Python 2中。

bin(x)
将整数转换为以“0b”为前缀的二进制字符串。结果是一个有效的Python表达式。如果x不是Pythonint对象时，它必须定义__index__()方法返回整数。一些例子：

>>>
>>> bin(3)
'0b11'
>>> bin(-10)
'-0b1010'
如果前缀“0b”是否需要，则可以使用以下任何一种方式。

>>>
>>> format(14, '#b'), format(14, 'b')
('0b1110', '1110')
>>> f'{14:#b}', f'{14:b}'
('0b1110', '1110')
另见format()想了解更多信息。

班级，等级bool([x])
返回一个布尔值，即True或False. x使用标准转换真理检验程序。如果x为假或省略，则返回False；否则它会返回True。这，这个，那，那个bool类是int(见数字类型-int、Float、Complex)它不能再被子类化了。它的唯一实例是False和True(见布尔值).

在3.7版中更改：x现在是一个只定位的参数。

breakpoint(*ARGS, *KWS)
此函数会将您放到调用站点的调试器中。具体来说，它调用sys.breakpointhook()擦肩而过args和kws直接穿过。默认情况下，sys.breakpointhook()打电话pdb.set_trace()期待没有争论。在本例中，它纯粹是一个方便函数，因此不必显式导入pdb或键入输入调试器的代码。然而，sys.breakpointhook()可以设置为其他函数，并且breakpoint()将自动调用，允许您跳入所选择的调试器。

New in version 3.7.

班级，等级bytearray([来源[, 编码[, 错误]]])
返回一个新的字节数组。这，这个，那，那个bytearray类是0<=x<256范围内的可变整数序列。它有大多数常见的可变序列方法，如可变序列类型，以及大多数方法bytes类型有，见字节和字节数组操作.

任选来源参数可用于以几种不同的方式初始化数组：

如果是弦，您还必须给编码(可选地，错误)参数；bytearray()然后使用以下方法将字符串转换为字节str.encode().
如果是整型，数组将具有该大小，并将使用空字节进行初始化。
如果它是一个符合缓冲器接口时，对象的只读缓冲区将用于初始化字节数组.
如果是可迭代，它必须是范围内整数的可迭代性。0 <= x < 256，它们用作数组的初始内容。
如果没有参数，则创建大小为0的数组。

另见二进制序列类型-字节、字节数组、内存视图和ByteArray对象.

班级，等级bytes([来源[, 编码[, 错误]]])
返回一个新的“字节”对象，它是范围内不可变的整数序列。0 <= x < 256. bytes的不可变版本。bytearray-它具有相同的非变异方法和同样的索引和切片行为。

因此，构造函数参数被解释为bytearray().

字节对象也可以用文字创建，请参见String和Bytes文字.

另见二进制序列类型-字节、字节数组、内存视图, 字节对象，和字节和字节数组操作.

callable(对象)
回归True如果对象参数看起来是可调用的，False如果不是。如果返回true，则仍有可能调用失败，但如果调用为false，则调用对象永远不会成功。注意，类是可调用的(调用类返回一个新实例)；如果类的类具有__call__()方法。

新版本3.2：This function was first removed in Python 3.0 and then brought back in Python 3.2.

chr(i)
返回表示Unicode代码点为整数的字符串。i。例如chr(97)返回字符串。'a'，同时chr(8364)返回字符串。'€'。这是ord().

参数的有效范围为0到1，114，111(基数16为0x10FFFF)。ValueError如果i超出了这个范围。

@classmethod
将方法转换为类方法。

类方法作为隐式第一个参数接收类，就像实例方法接收实例一样。要声明类方法，请使用以下成语：

class C:
    @classmethod
    def f(cls, arg1, arg2, ...): ...
这，这个，那，那个@classmethod形式是一个函数装饰师-参见函数定义关于细节。

可以在类中调用它(如C.f())或实例(例如C().f())除了它的类之外，实例将被忽略。如果为派生类调用类方法，派生类对象将作为隐含的第一个参数传递。

类方法不同于C+或Java静态方法。如果你想要的话，看staticmethod()在这部分。

有关类方法的更多信息，请参阅标准类型层次结构.

compile(来源, 文件名, 模式, 标志=0, 不继承=假, 优化=-1)
编译来源变成代码或AST对象。代码对象可以由exec()或eval(). 来源可以是普通字符串、字节字符串或AST对象。参考ast有关如何使用AST对象的信息的模块文档。

这，这个，那，那个文件名参数应给出读取代码的文件；如果没有从文件读取代码，则传递一些可识别的值('<string>'是常用的)。

这，这个，那，那个模式参数指定必须编译哪种代码；它可以是'exec'如果来源由一系列声明组成，'eval'如果它由一个表达式组成，或者'single'如果它由单个交互式语句组成(在后一种情况下，表达式语句的计算值为None将印刷)。

可选参数旗子和不继承控制哪个今后的声明影响汇编来源。如果两者都不存在(或者两者都为零)，则代码将使用正在调用的代码中有效的那些未来语句进行编译。compile()。如果旗子给出了论点不继承对象指定的未来语句不是(或为零)。旗子除了那些无论如何都会用到的参数外，还使用了参数。如果不继承为非零整数，则为旗子参数就是它-对编译的调用周围的未来语句将被忽略。

未来的语句是由位指定的，这些位可以一起按位来指定多个语句。指定给定功能所需的位字段可作为compiler_flag属性的_Feature实例中的__future__模块。

争论优化指定编译器的优化级别；默认值为-1给出的解释器的优化级别。-O各种选择。显式级别是0(没有优化；__debug__是真的)，1(权利被移除，__debug__是虚假的)或2(也删除了文档字符串)。

此功能引发SyntaxError如果编译的源代码无效，则ValueError如果源包含空字节。

如果要将Python代码解析为AST表示形式，请参见ast.parse().

注 中使用多行代码编译字符串时'single'或'eval'模式下，输入必须以至少一个换行符结束。这是为了便于在code模块。
警告 由于Python的AST编译器中的堆栈深度限制，编译到AST对象时可以使用足够大/复杂的字符串使Python解释器崩溃。
在3.2版中更改：允许使用Windows和Mac换行符。也输入'exec'模式不再需要以换行符结尾。添加优化参数。

在3.5版中更改：以前，TypeError中遇到空字节时引发来源.

班级，等级complex([真品[, 马格]])
返回具有以下值的复数真品 + 马格*1J或将字符串或数字转换为复数。如果第一个参数是字符串，它将被解释为一个复数，函数必须在没有第二个参数的情况下调用。第二个参数永远不可能是字符串。每个参数都可以是任何数字类型(包括复杂类型)。如果马格，默认为零，构造函数充当数值转换，如下所示int和float。如果省略了这两个参数，则返回0j.

注 从字符串转换时，字符串不能包含中心周围的空格。+或-接线员。例如complex('1+2j')很好，但是complex('1 + 2j')提高ValueError.
复杂类型在数字类型-int、Float、Complex.

在3.6版中更改：允许将数字与代码文本中的下划线进行分组。

delattr(对象, 名字，姓名)
这是…的亲戚setattr()。参数是一个对象和一个字符串。字符串必须是对象的一个属性的名称。如果对象允许，该函数将删除命名属性。例如delattr(x, 'foobar')等于del x.foobar.

班级，等级dict(*kwarg)
班级，等级dict(映射, *kwarg)
班级，等级dict(可迭代, *kwarg)
创建一本新词典。这，这个，那，那个dict对象是字典类。看见dict和映射类型-DECT有关这个类的文档。

有关其他容器，请参阅内置的list, set，和tuple类，以及collections模块。

dir([对象])
如果没有参数，则返回当前本地范围中的名称列表。使用参数，尝试返回该对象的有效属性列表。

如果对象有一个名为__dir__()，此方法将被调用，必须返回属性列表。这允许实现自定义的对象。__getattr__()或__getattribute__()函数来自定义dir()报告它们的属性。

如果对象不提供__dir__()，该函数尽力从对象的__dict__属性，如果已定义，则从其类型对象。结果列表不一定完整，当对象具有自定义时，该列表可能是不准确的。__getattr__().

默认dir()机制对不同类型的对象的行为不同，因为它试图生成最相关的信息，而不是完整的信息：

如果对象是模块对象，则列表包含模块属性的名称。
如果对象是类型或类对象，则列表包含其属性的名称，以及其基的属性的递归名称。
否则，列表包含对象的属性名称、类属性的名称以及类基类的属性的递归名称。
结果列表按字母顺序排序。例如：

>>>
>>> import struct
>>> dir()   # show the names in the module namespace  
['__builtins__', '__name__', 'struct']
>>> dir(struct)   # show the names in the struct module 
['Struct', '__all__', '__builtins__', '__cached__', '__doc__', '__file__',
 '__initializing__', '__loader__', '__name__', '__package__',
 '_clearcache', 'calcsize', 'error', 'pack', 'pack_into',
 'unpack', 'unpack_from']
>>> class Shape:
...     def __dir__(self):
...         return ['area', 'perimeter', 'location']
>>> s = Shape()
>>> dir(s)
['area', 'location', 'perimeter']
注 因为dir()主要是为了方便在交互提示下使用，它试图提供一组有趣的名称，而不是试图提供严格或一致定义的名称集，并且它的详细行为可能在不同版本之间发生变化。例如，当参数是类时，元类属性不在结果列表中。
divmod(a, b)
以两个(非复数)数作为参数，在使用整数除法时返回由它们的商和余数组成的一对数字。对于混合操作数类型，适用于二进制算术运算符的规则。对于整数，结果与(a // b, a % b)。对于浮点数，结果是(q, a % b)，在哪里q通常是math.floor(a / b)但可能比那少一个。无论如何q * b + a % b非常接近a，如果a % b是非零的，它的符号与b，和0 <= abs(a % b) < abs(b).

enumerate(可迭代, 开始=0)
返回枚举对象。可迭代一定是一个序列，一个迭代器，或者支持迭代的其他对象。这，这个，那，那个__next__()返回的迭代器的enumerate()返回包含计数的元组(从启动，它的默认值为0)，以及从迭代过程中获得的值。可迭代.

>>>
>>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']
>>> list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
>>> list(enumerate(seasons, start=1))
[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
相当于：

def enumerate(sequence, start=0):
    n = start
    for elem in sequence:
        yield n, elem
        n += 1
eval(表达, 全局=无, 当地人=无)
参数是字符串和可选的全局值和局部变量。如果提供，全球一定是字典。如果提供，本地人可以是任何映射对象。

这，这个，那，那个表达参数作为Python表达式(从技术上讲，是条件列表)使用全球和本地人字典作为全局和本地命名空间。如果全球字典是存在的，并且不包含键的值。__builtins__，对内置模块的字典的引用。builtins被插入在前面的那个键下面。表达被解析了。这意味着表达通常可以完全访问标准builtins模块和受限环境被传播。如果本地人字典被省略，它默认为全球字典。如果省略了这两个字典，表达式将在以下环境中执行eval()叫做。返回值是计算表达式的结果。语法错误报告为异常。例子：

>>>
>>> x = 1
>>> eval('x+1')
2
此函数还可用于执行任意代码对象(例如compile())在本例中，传递代码对象而不是字符串。如果代码对象是用'exec'就像模式争论，eval()返回值为None.

提示：语句的动态执行由exec()功能。这，这个，那，那个globals()和locals()函数分别返回当前的全局字典和本地字典，这对于传递给eval()或exec().

看见ast.literal_eval()对于可以使用仅包含文本的表达式安全地计算字符串的函数。

exec(对象[, 全球[, 本地人]])
此函数支持Python代码的动态执行。对象必须是字符串或代码对象。如果是字符串，则将字符串解析为一组Python语句，然后执行这些语句(除非出现语法错误)。[1]如果它是一个代码对象，则简单地执行它。在任何情况下，执行的代码都将作为文件输入有效(参见参考手册中的“文件输入”部分)。请注意，return和yield语句不能在函数定义之外使用，即使在传递给exec()功能。返回值为None.

在所有情况下，如果省略可选部分，代码将在当前范围内执行。要是全球它必须是一个字典，它将用于全局变量和局部变量。如果全球和本地人分别用于全局变量和局部变量。如果提供，本地人可以是任何映射对象。请记住，在模块级别上，全局词和局部变量是相同的字典。如果exec获得两个单独的对象，如全球和本地人，代码将被执行，就像它嵌入到类定义中一样。

如果全球字典不包含键的值。__builtins__，对内置模块的字典的引用。builtins被插入到那个键下面。这样，您就可以通过插入自己的代码来控制已执行代码可用的内置程序。__builtins__字典成全球在把它传给exec().

注 内建函数globals()和locals()分别返回当前的全局字典和本地字典，将其作为第二个和第三个参数传递给exec().
注 默认本地人按所述的功能行事locals()下面：对默认值的修改本地人不应尝试使用字典。传递显式本地人如果需要查看代码对本地人后功能exec()退货。
filter(功能, 可迭代)
的元素构造迭代器。可迭代对此功能返回真。可迭代可以是序列、支持迭代的容器，也可以是迭代器。如果功能是None的所有元素都被假定为身份函数。可迭代那些是假的被删除了。

请注意filter(function, iterable)等于生成器表达式。(item for item in iterable if function(item))如果函数不是None和(item for item in iterable if item)如果函数是None.

看见itertools.filterfalse()的互补函数返回可迭代对此功能返回假。

班级，等级float([x])
返回由数字或字符串构造的浮点数。x.

如果参数是字符串，则它应该包含一个小数，可选地在前面加上一个符号，并可选择地嵌入空白中。可选的标志可能是'+'或'-'a；a'+'符号对产生的价值没有影响。参数还可以是表示NaN(非a-数字)的字符串，或表示正无穷大或负无穷大的字符串。更准确地说，在删除前导和尾随空格字符后，输入必须符合以下语法：

sign           ::=  "+" | "-"
infinity       ::=  "Infinity" | "inf"
nan            ::=  "nan"
numeric_value  ::=  floatnumber | infinity | nan
numeric_string ::=  [sign] numeric_value
这里floatnumber是Python浮点文字的形式，在浮点文字。大小写没有意义，因此，例如，“inf”、“无穷大”和“无穷大”都是正无穷大的可接受拼写。

否则，如果参数是整数或浮点数，则返回相同值(在Python浮点精度范围内)的浮点数。如果参数超出Python浮动的范围，则OverflowError将被提升。

对于一般Python对象x, float(x)代表出席x.__float__().

如果没有争论，0.0会被归还。

例子：

>>>
>>> float('+1.23')
1.23
>>> float('   -12345\n')
-12345.0
>>> float('1e-003')
0.001
>>> float('+1E6')
1000000.0
>>> float('-Infinity')
-inf
浮点类型在数字类型-int、Float、Complex.

在3.6版中更改：允许将数字与代码文本中的下划线进行分组。

在3.7版中更改：x现在是一个只定位的参数。

format(价值[, 格式规范])
转换价值为“格式化”表示形式，由格式规范。对.的解释格式规范将取决于价值参数，但是，大多数内置类型都使用标准格式语法：格式规范-微型语言.

默认格式规范是一个空字符串，它通常具有与调用相同的效果。str(value).

打电话给format(value, format_spec)翻译成type(value).__format__(value, format_spec)，它在搜索值时绕过实例字典。__format__()方法。一个TypeError如果方法搜索到达object而格式规范是非空的，或者如果格式规范或者返回值不是字符串。

在3.4版中更改：object().__format__(format_spec)提高TypeError如果格式规范不是空字符串。

班级，等级frozenset([可迭代])
返回一个新的frozenset对象，可以选择使用从可迭代. frozenset是一个内置的班级。看见frozenset和集合类型-设置，冻结有关这个类的文档。

有关其他容器，请参阅内置的set, list, tuple，和dict类，以及collections模块。

getattr(对象, 名字，姓名[, 违约])
的命名属性的值。对象. 名字，姓名一定是一根绳子。如果字符串是对象属性之一的名称，则结果是该属性值。例如getattr(x, 'foobar')等于x.foobar。如果命名属性不存在，违约如果提供，则为AttributeError已经长大了。

globals()
返回表示当前全局符号表的字典。这始终是当前模块的字典(在函数或方法中，这是定义它的模块，而不是调用它的模块)。

hasattr(对象, 名字，姓名)
参数是一个对象和一个字符串。结果是True如果字符串是对象的一个属性的名称，False如果不是。(这是通过调用getattr(object, name)看看它是否会引发AttributeError或者不是。)

hash(对象)
返回对象的哈希值(如果有)。散列值是整数。它们用于在查找字典时快速比较字典键。比较相等的数值具有相同的散列值(即使它们是不同的类型，如1和1.0的情况)。

注 对于具有自定义的对象__hash__()方法，注意hash()根据主机的位宽截断返回值。看见__hash__()关于细节。
help([对象])
调用内置帮助系统。(这一功能是供交互式使用的。)如果不提供任何参数，则交互式帮助系统将在解释器控制台上启动。如果参数是字符串，则该字符串将被查找为模块、函数、类、方法、关键字或文档主题的名称，并在控制台上打印帮助页。如果参数是任何其他类型的对象，则会在该对象上生成一个帮助页。

属性将此函数添加到内置命名空间中。site模块。

在3.4版中更改：改变到pydoc和inspect这意味着报告的可调用性签名现在更加全面和一致。

hex(x)
将整数转换为以“0x”为前缀的小写十六进制字符串。如果x不是Pythonint对象时，它必须定义__index__()方法返回整数。一些例子：

>>>
>>> hex(255)
'0xff'
>>> hex(-42)
'-0x2a'
如果要将整数转换为大写或小写十六进制字符串(前缀与否)，可以使用下列任何一种方法：

>>>
>>> '%#x' % 255, '%x' % 255, '%X' % 255
('0xff', 'ff', 'FF')
>>> format(255, '#x'), format(255, 'x'), format(255, 'X')
('0xff', 'ff', 'FF')
>>> f'{255:#x}', f'{255:x}', f'{255:X}'
('0xff', 'ff', 'FF')
另见format()想了解更多信息。

另见int()用于使用基数为16将十六进制字符串转换为整数。

注 若要获取浮点数的十六进制字符串表示形式，请使用float.hex()方法。
id(对象)
返回对象的“标识”。这是一个整数，它保证该对象在其生存期内是唯一的和常量的。两个生命周期不重叠的对象可能具有相同的生命周期。id()价值。

CPython实现细节：这是内存中对象的地址。

input([提示符])
如果提示符参数存在时，它被写入标准输出，而不带尾换行符。然后，函数从输入中读取一行，将其转换为字符串(去掉尾随的换行符)，并返回该字符串。当阅读EOF时，EOFError已经长大了。例子：

>>>
>>> s = input('--> ')  
--> Monty Python's Flying Circus
>>> s  
"Monty Python's Flying Circus"
如果readline模块被加载，然后input()将使用它提供详细的行编辑和历史功能。

班级，等级int([x])
班级，等级int(x, 基=10)
返回由数字或字符串构造的整数对象。x，或返回0如果没有人提出任何论据。如果x定义__int__(), int(x)回报x.__int__()。如果x定义__trunc__()，它回来了x.__trunc__()。对于浮点数，这将截断为零。

如果x不是一个数字或者如果底座是给出的，那么x一定是一根线，bytes，或bytearray实例表示整数字基底座。还可以选择在文字之前加上+或-(中间没有空格)并被空格包围。基-n字面值由数字0到n-1组成，a到z(或A到Z)具有10到35的值。默认底座是10。允许的值是0和2-36.基-2、-8和-16的文字可以有可选的前缀。0b/0B, 0o/0O，或0x/0X，与代码中的整数字面值一样。基0意味着准确地解释为代码文字，因此实际的基值是2、8、10或16，所以int('010', 0)是不合法的int('010')是，以及int('010', 8).

整数类型在数字类型-int、Float、Complex.

在3.4版中更改：如果底座的实例int而底座对象具有base.__index__方法，则调用该方法以获取基值的整数。以前使用的版本base.__int__而不是base.__index__.

在3.6版中更改：允许将数字与代码文本中的下划线进行分组。

在3.7版中更改：x现在是一个只定位的参数。

isinstance(对象, 类信息)
如果对象参数的实例。类信息(直接、间接或)论点虚拟)其子类。如果对象不是给定类型的对象，函数总是返回false。如果类信息是类型对象的元组(或递归地，其他这样的元组)，如果对象是任何类型的实例。如果类信息不是类型或元组的类型或元组，则为TypeError引发异常。

issubclass(班级，等级, 类信息)
返回true如果班级，等级是子类(直接、间接或虚拟)类信息。类本身被视为子类。类信息可能是类对象的元组，在这种情况下，类信息会被检查的。在任何其他情况下，TypeError引发异常。

iter(对象[, 哨兵])
退货迭代器对象。根据第二个参数的存在，对第一个参数的解释非常不同。没有第二次争论，对象必须是支持迭代协议的集合对象(__iter__()方法，或者它必须支持序列协议(__getitem__()方法的整数参数开始于0)如果它不支持这两项协议中的任何一项，TypeError已经长大了。如果第二个论点，哨兵，给出，然后对象必须是可调用对象。在本例中创建的迭代器将调用对象的每个调用都没有参数。__next__()方法；如果返回的值等于哨兵, StopIteration将引发，否则将返回值。

另见迭代器类型.

的第二种形式的一个有用的应用iter()是读取文件的行，直到到达某一行为止。下面的示例读取文件，直到readline()方法返回空字符串：

with open('mydata.txt') as fp:
    for line in iter(fp.readline, ''):
        process_line(line)
len(s)
返回对象的长度(项目数)。参数可以是序列(例如字符串、字节、元组、列表或范围)或集合(例如字典、集合或冻结集)。

班级，等级list([可迭代])
而不是作为一种功能，list实际上是可变序列类型，如列表和序列类型-列表元组范围.

locals()
更新并返回表示当前本地符号表的字典。自由变量由locals()当它在函数块中被调用时，而不是在类块中。

注 不应修改本词典的内容；更改可能不会影响解释器使用的局部变量和空闲变量的值。
map(功能, 可迭代, ...)
返回应用程序的迭代器功能每一项可迭代，产生结果。如果附加可迭代通过了论点，功能必须接受这么多参数，并行地应用于所有可迭代项。对于多个可迭代性，迭代器将在最短的可迭代性耗尽时停止。有关函数输入已排列为参数元组的情况，请参见itertools.starmap().

max(可迭代, *[, 钥匙, 违约])
max(arg 1, ARG 2, *ARGS[, 钥匙])
返回可迭代或两个或多个参数中最大的项。

如果提供了一个位置参数，则应该是可迭代。返回可迭代中最大的项。如果提供两个或多个位置参数，则返回最大的位置参数。

有两个可选的关键字-纯参数。这，这个，那，那个钥匙参数指定一个参数排序函数，类似于list.sort()。这，这个，那，那个违约参数指定提供的可迭代对象为空时返回的对象。如果可迭代是空的，并且违约未提供，则为ValueError已经长大了。

如果多个项最大，则函数返回第一个遇到的项。这与其他保持稳定的工具是一致的，例如sorted(iterable, key=keyfunc, reverse=True)[0]和heapq.nlargest(1, iterable, key=keyfunc).

3.4版新版本：这，这个，那，那个违约只有关键字的参数。

memoryview(OBJ)
返回从给定参数创建的“内存视图”对象。看见内存视图想了解更多信息。

min(可迭代, *[, 钥匙, 违约])
min(arg 1, ARG 2, *ARGS[, 钥匙])
返回可迭代或两个或多个参数中最小的项。

如果提供了一个位置参数，则应该是可迭代。返回迭代中最小的项。如果提供两个或多个位置参数，则返回最小的位置参数。

有两个可选的关键字-纯参数。这，这个，那，那个钥匙参数指定一个参数排序函数，类似于list.sort()。这，这个，那，那个违约参数指定提供的可迭代对象为空时返回的对象。如果可迭代是空的，并且违约未提供，则为ValueError已经长大了。

如果多个项最小，则函数将返回遇到的第一个项。这与其他保持稳定的工具是一致的，例如sorted(iterable, key=keyfunc)[0]和heapq.nsmallest(1, iterable, key=keyfunc).

3.4版新版本：这，这个，那，那个违约只有关键字的参数。

next(迭代器[, 违约])
从迭代器通过调用它__next__()方法。如果违约如果迭代器耗尽，则返回StopIteration已经长大了。

班级，等级object
返回一个新的无特征对象。object是所有课程的基础。它拥有Python类的所有实例所共有的方法。此函数不接受任何参数。

注 object是吗？不有__dict__，因此不能将任意属性分配给object班级，等级
oct(x)
将整数转换为以“0o”为前缀的八进制字符串。结果是一个有效的Python表达式。如果x不是Pythonint对象时，它必须定义__index__()方法返回整数。例如：

>>>
>>> oct(8)
'0o10'
>>> oct(-56)
'-0o70'
如果要将整数转换为具有前缀“0o”或不带前缀的八进制字符串，则可以使用下列任何一种方法。

>>>
>>> '%#o' % 10, '%o' % 10
('0o12', '12')
>>> format(10, '#o'), format(10, 'o')
('0o12', '12')
>>> f'{10:#o}', f'{10:o}'
('0o12', '12')
另见format()想了解更多信息。

open(档案, 模式=‘r’, 缓冲=-1, 编码=无, 错误=无, Newline=无, Closefd=True, 开瓶器=无)
打开档案并返回相应的文件对象。如果无法打开文件，则OSError已经长大了。

档案是类路径对象给出要打开的文件的路径名(绝对的或相对于当前工作目录)或要包装的文件的整数文件描述符。(如果给定文件描述符，则在关闭返回的I/O对象时关闭该描述符，除非密闭设置为False.)

模式指定打开文件的模式的可选字符串。默认为'r'这意味着以文本模式打开阅读。其他公共值包括'w'用于写入(如果文件已经存在，则截断该文件)，'x'为独占创作和'a'用于追加(在一些Unix系统，意味着全将其写入文件的末尾，而不考虑当前的查找位置)。在文本模式下，如果编码未指定所使用的编码依赖于平台：locale.getpreferredencoding(False)调用以获取当前区域设置编码。(对于读取和写入原始字节，请使用二进制模式并离开。编码(未指明)可用的模式如下：

字	意义
'r'	打开阅读(默认)
'w'	打开以便写入，首先截断文件
'x'	打开以进行独占创建，如果文件已经存在，则失败。
'a'	打开以便写入，如果文件存在，则追加到文件的末尾。
'b'	二元模式
't'	文本模式(默认)
'+'	打开磁盘文件以进行更新(读和写)
'U'	通用换行符模式(不赞成)
默认模式是'r'(开放阅读课文，同义词'rt')对于二进制读写访问，模式'w+b'打开文件并将其截断为0字节。'r+b'打开文件而不截断。

如概述，Python区分二进制和文本I/O。以二进制模式打开的文件(包括'b'在.。模式参数)返回内容为bytes没有任何解码的对象。在文本模式下(默认或't'包含在模式参数)时，文件的内容将作为str，第一次使用依赖于平台的编码或使用指定的编码如果给了。

注 Python不依赖底层操作系统的文本文件概念；所有的处理都是由Python自己完成的，因此是独立于平台的。
缓冲用于设置缓冲策略的可选整数。传递0以关闭缓冲(仅在二进制模式下允许)，1选择行缓冲(仅在文本模式中可用)，以及整数>1以字节表示固定大小块缓冲区的大小。当没有缓冲参数时，默认缓冲策略的工作原理如下：

二进制文件以固定大小的块缓冲；缓冲区的大小是使用启发式方法选择的，试图确定底层设备的“块大小”并返回到io.DEFAULT_BUFFER_SIZE。在许多系统上，缓冲区通常为4096字节或8192字节。
“交互式”文本文件(其中的文件isatty()回报True)使用行缓冲。其他文本文件对二进制文件使用上述策略。
编码用于解码或编码文件的编码的名称。这应该只在文本模式中使用。默认编码依赖于平台(任何内容)。locale.getpreferredencoding())，但任何文本编码可以使用Python支持的。见codecs模块，用于所支持的编码列表。

错误是一个可选字符串，它指定如何处理编码和解码错误-不能在二进制模式中使用。有多种标准错误处理程序可用(如下所示)错误处理程序)，尽管已注册的任何错误处理名称codecs.register_error()也是有效的。标准名称包括：

'strict'提出ValueError如果存在编码错误，则为例外。的默认值None也有同样的效果。
'ignore'忽略错误。注意，忽略编码错误会导致数据丢失。
'replace'导致替换标记(如'?')在有格式错误的数据的地方插入。
'surrogateescape'将任何不正确的字节表示为Unicode专用区域中的代码点，范围从U+DC 80到U+DCFF。然后，这些私有代码点将被转换为相同的字节。surrogateescape在写入数据时使用错误处理程序。这对于以未知编码处理文件很有用。
'xmlcharrefreplace'仅在写入文件时才支持。编码不支持的字符将替换为适当的xml字符引用。&#nnn;.
'backslashreplace'用Python的反斜杠转义序列替换格式错误的数据。
'namereplace'(仅在写入时才支持)将不支持的字符替换为\N{...}逃逸序列。
纽林控制通用换行符模式有效(它只适用于文本模式)。可能是None, '', '\n', '\r'，和'\r\n'。它的工作如下：

从流读取输入时，如果纽林是None，启用通用换行符模式。输入中的行可以以'\n', '\r'，或'\r\n'，这些被翻译成'\n'在被送回给来电者之前。如果是的话''，启用通用换行符模式，但行尾将返回给未翻译的调用方。如果它具有任何其他合法值，则输入行仅由给定字符串终止，并将行结束返回给调用方。
将输出写入流时，如果纽林是None，任何'\n'写入的字符被转换为系统默认行分隔符，os.linesep。如果纽林是''或'\n'没有翻译。如果纽林是任何其他的法律价值，任何'\n'所写的字符被翻译成给定的字符串。
如果密闭是False并且给出了文件描述符而不是文件名，当文件关闭时，底层文件描述符将保持打开状态。如果给出文件名密闭一定是True(默认值)否则将引发错误。

可以通过将可调用的开瓶器。然后通过调用开瓶器用(档案, 旗子). 开瓶器必须返回打开的文件描述符(传递os.open如开瓶器导致类似于传递的功能None).

新创建的文件是不可遗传.

下面的示例使用dir_fd参数的os.open()函数打开相对于给定目录的文件：

>>>
>>> import os
>>> dir_fd = os.open('somedir', os.O_RDONLY)
>>> def opener(path, flags):
...     return os.open(path, flags, dir_fd=dir_fd)
...
>>> with open('spamspam.txt', 'w', opener=opener) as f:
...     print('This will be written to somedir/spamspam.txt', file=f)
...
>>> os.close(dir_fd)  # don't leak a file descriptor
类型文件对象由open()函数取决于模式。什么时候open()用于以文本模式打开文件('w', 'r', 'wt', 'rt')，则返回io.TextIOBase(特别是io.TextIOWrapper)在使用缓冲以二进制模式打开文件时，返回的类是io.BufferedIOBase。确切的类是不同的：在读二进制模式下，它返回一个io.BufferedReader；在写二进制模式和附加二进制模式中，它返回io.BufferedWriter，在读/写模式下，它返回io.BufferedRandom。当缓冲区被禁用时，原始流是io.RawIOBase, io.FileIO，被归还。

还请参阅文件处理模块，例如，fileinput, io(在哪里open()宣布)，os, os.path, tempfile，和shutil.

在3.3版中更改：
这，这个，那，那个开瓶器参数添加。
这，这个，那，那个'x'添加模式。
IOError以前是引发的，现在它是OSError.
FileExistsError如果在独占创建模式下打开的文件('x')已经存在。
在3.4版中更改：
该文件现在不可继承.
自3.4版起被弃用，将在4.0版中删除：这，这个，那，那个'U'模式。

在3.5版中更改：
如果系统调用中断，而信号处理程序不引发异常，则该函数现在重新尝试系统调用，而不是引发InterruptedError例外(见佩普475的理由)。
这，这个，那，那个'namereplace'添加了错误处理程序。
在3.6版中更改：
添加以接受实现的对象的支持os.PathLike.
在Windows上，打开控制台缓冲区可能会返回io.RawIOBase除io.FileIO.
ord(c)
给定一个表示一个Unicode字符的字符串，返回一个表示该字符的Unicode代码点的整数。例如ord('a')返回整数。97和ord('€')(欧元符号)回报8364。这是chr().

pow(x, y[, z])
回归x到权力y；如果z存在，返回x到权力y模z(计算效率比pow(x, y) % z)双元形式pow(x, y)等于使用电源操作员：x**y.

参数必须具有数字类型。对于混合操作数类型，适用二进制算术运算符的强制规则。为int操作数，除非第二个参数为负值，否则结果与操作数的类型相同(强制后)；在这种情况下，所有参数都转换为浮点数，并传递浮点结果。例如10**2回报100，但是10**-2回报0.01。如果第二个参数是否定的，则必须省略第三个参数。如果z是存在的，x和y必须是整数类型，并且y肯定是非阴性的。

print(*物体, 9月=‘, End=‘n’, file=sys.stdout, 刷新=假)
列印对象到文本流档案，被九月然后是端部. 九月, 端部, 档案和冲水，如果存在，则必须作为关键字参数给出。

所有非关键字参数都转换为字符串，如str()并将其写入流中，并将其分隔为九月然后是端部。双管齐下九月和端部必须是字符串；它们也可以是None，这意味着使用默认值。如果没有对象被给予，print()只会写端部.

这，这个，那，那个档案参数必须是具有write(string)方法；如果它不存在或None, sys.stdout会被使用。由于打印的参数被转换为文本字符串，print()不能与二进制模式文件对象一起使用。对于这些，使用file.write(...)相反。

输出是否缓冲通常由档案但是如果冲水关键字参数为真，流被强制刷新。

在3.3版中更改：添加冲水关键字参数

班级，等级property(fget=无, fset=无, fdel=无, DOC=无)
返回属性。

fget是用于获取属性值的函数。福塞特用于设置属性值的函数。范德尔是用于删除属性值的函数。和博士为属性创建一个docstring。

典型的用法是定义托管属性。x:

class C:
    def __init__(self):
        self._x = None

    def getx(self):
        return self._x

    def setx(self, value):
        self._x = value

    def delx(self):
        del self._x

    x = property(getx, setx, delx, "I'm the 'x' property.")
如果c是C, c.x会调用getter，c.x = value将调用setter和del c.x删除者。

如果给了你，博士将是属性的docstring。否则，该属性将复制。fget的docstring(如果存在的话)。这样就可以轻松地使用property()作为装饰师:

class Parrot:
    def __init__(self):
        self._voltage = 100000

    @property
    def voltage(self):
        """Get the current voltage."""
        return self._voltage
这，这个，那，那个@property装饰师voltage()方法转换为具有相同名称的只读属性的“getter”，并将docstring设置为电压“得到电流电压”

属性对象getter, setter，和deleter方法可用作装饰器，用于创建属性的副本，并将相应的访问器函数设置为修饰函数。最好用一个例子来解释：

class C:
    def __init__(self):
        self._x = None

    @property
    def x(self):
        """I'm the 'x' property."""
        return self._x

    @x.setter
    def x(self, value):
        self._x = value

    @x.deleter
    def x(self):
        del self._x
此代码与第一个示例完全等价。请确保为附加函数赋予与原始属性相同的名称(x在这种情况下)

返回的属性对象也具有以下属性fget, fset，和fdel对应于构造函数参数。

在3.5版中更改：属性对象的文档字符串现在是可写的。

range(停，停止)
range(启动, 停，停止[, 步进])
而不是作为一种功能，range实际上是不可变的序列类型，如范围和序列类型-列表元组范围.

repr(对象)
返回包含对象的可打印表示形式的字符串。对于许多类型，此函数尝试返回一个字符串，该字符串将在传递给eval()否则，表示形式是一个括在尖括号中的字符串，该字符串包含对象类型的名称以及其他信息(通常包括对象的名称和地址)。类可以通过定义__repr__()方法。

reversed(SEQ)
返回反向迭代器. SEQ必须是具有__reversed__()方法或支持序列协议(__len__()方法和__getitem__()方法的整数参数开始于0).

round(数[, 数位])
回归数四舍五入数位小数点之后的精度。如果数位被省略或是None，则返回其输入的最接近的整数。

为内置类型提供支持。round()，则值四舍五入到与幂减最接近的倍数10。数位；如果两个倍数相等接近，则对偶数选择进行舍入(例如，两者都是)。round(0.5)和round(-0.5)是0，和round(1.5)是2)任何整数值对数位(正、零或负)。返回值是一个整数，如果数位省略或None。否则，返回值的类型与数.

对于一般Python对象number, round代表出席number.__round__.

注 .的行为round()对于浮标来说，可能是令人惊讶的：例如，round(2.675, 2)施予2.67而不是预期的2.68。这不是一个错误：它是一个事实的结果，大多数十进制分数不能被精确地表示为浮点数。看见浮点算法的问题与局限性想了解更多信息。
班级，等级set([可迭代])
返回一个新的set对象，可以选择使用从可迭代. set是一个内置的班级。看见set和集合类型-设置，冻结有关这个类的文档。

有关其他容器，请参阅内置的frozenset, list, tuple，和dict类，以及collections模块。

setattr(对象, 名字，姓名, 价值)
这是对应的getattr()。参数是一个对象、一个字符串和一个任意值。字符串可以命名现有属性或新属性。如果对象允许，该函数将值赋给属性。例如setattr(x, 'foobar', 123)等于x.foobar = 123.

班级，等级slice(停，停止)
班级，等级slice(启动, 停，停止[, 步进])
返回a切片对象，表示由range(start, stop, step)。这，这个，那，那个启动和步进参数默认为None。片对象具有只读数据属性。start, stop和step它只返回参数值(或它们的默认值)。它们没有其他显式功能；但是，它们被数值Python和其他第三方扩展使用。在使用扩展索引语法时也会生成片对象。例如：a[start:stop:step]或a[start:stop, i]。看见itertools.islice()对于返回迭代器的替代版本。

sorted(可迭代, *, 键=无, 反向=假)
中的项返回一个新排序列表。可迭代.

有两个可选参数，必须指定为关键字参数。

钥匙指定一个参数的函数，该函数用于从每个List元素中提取比较键：key=str.lower。默认值是None(直接比较元素)。

倒转是一个布尔值。如果设置为True，然后对列表元素进行排序，就好像每个比较都被颠倒了一样。

使用functools.cmp_to_key()转换旧样式CMP函数为钥匙功能。

内建sorted()功能是稳定的。如果保证不更改比较相等的元素的相对顺序，则排序是稳定的-这有助于对多个传递进行排序(例如，按部门排序，然后按薪等排序)。

有关排序示例和简要排序教程，请参见分类如何.

@staticmethod
将方法转换为静态方法。

静态方法不接收隐式第一个参数。要声明静态方法，请使用以下成语：

class C:
    @staticmethod
    def f(arg1, arg2, ...): ...
这，这个，那，那个@staticmethod形式是一个函数装饰师-参见函数定义关于细节。

可以在类中调用它(如C.f())或实例(例如C().f())除了它的类之外，实例将被忽略。

Python中的静态方法与Java或C+中的方法相似。亦见classmethod()对于一个对创建备用类构造函数有用的变体。

就像所有的装潢师一样，也可以调用staticmethod作为一个有规律的函数，做一些事情并得到它的结果。在某些情况下，您需要从类主体引用函数，并且希望避免将其自动转换为实例方法，这是必要的。对于这些情况，请使用以下成语：

class C:
    builtin_open = staticmethod(open)
有关静态方法的更多信息，请参阅标准类型层次结构.

班级，等级str(Object=‘)
班级，等级str(对象=b‘, 编码=‘utf-8’, 错误=“严格”)
返回astr版本对象。看见str()关于细节。

str是内置字符串。班级，等级。有关字符串的一般信息，请参阅文本序列类型-str.

sum(可迭代[, 启动])
总金额启动的项目可迭代从左到右并返回总数。启动默认为0。这，这个，那，那个可迭代其项通常是数字，并且不允许开始值是字符串。

对于一些用例，有很好的替代方案sum()。连接字符串序列的首选、快速的方法是调用''.join(sequence)。若要添加具有扩展精度的浮点值，请参见math.fsum()。若要连接一系列可迭代性，请考虑使用itertools.chain().

super([类型[, 对象或类型]])
返回代理对象，该对象将方法调用委托给类型。这对于访问已在类中重写的继承方法非常有用。搜索顺序与getattr()除了类型它本身被跳过了。

这，这个，那，那个__mro__属性的类型列出双方使用的方法解析搜索顺序。getattr()和super()。该属性是动态的，可以在更新继承层次结构时进行更改。

如果省略了第二个参数，则返回的超级对象将被解除绑定。如果第二个参数是一个对象，isinstance(obj, type)一定是真的。如果第二个参数是类型，issubclass(type2, type)必须是真(这对类方法很有用)。

有两个典型的用例超级。在具有单一继承的类层次结构中，超级可以用于引用父类，而无需显式命名它们，从而使代码更易于维护。此使用与使用超级其他编程语言。

第二个用例是支持动态执行环境中的协作多继承。这个用例是Python特有的，在静态编译的语言或只支持单一继承的语言中没有发现。这使得实现多个基类实现相同方法的“菱形图”成为可能。良好的设计要求此方法在每种情况下都具有相同的调用签名(因为调用顺序是在运行时确定的，因为该顺序适应类层次结构中的更改，而且该顺序可以包括运行时之前未知的同级类)。

对于这两个用例，典型的超类调用如下所示：

class C(B):
    def method(self, arg):
        super().method(arg)    # This does the same thing as:
                               # super(C, self).method(arg)
请注意super()作为显式虚线属性查找的绑定过程的一部分实现，如super().__getitem__(name)。它通过实现自己的__getattribute__()方法，用于以支持协作多继承的可预测顺序搜索类。因此，super()对于使用语句或运算符(如super()[name].

还请注意，除了零参数形式之外，super()不限于使用内部方法。这两个参数表单精确地指定了参数，并进行了适当的引用。零参数表单仅在类定义中工作，因为编译器填充必要的详细信息以正确检索所定义的类，以及访问普通方法的当前实例。

关于如何设计协作类的实用建议super()，见使用超级()指南.

tuple([可迭代])
而不是作为一种功能，tuple实际上是不可变的序列类型，如元组和序列类型-列表元组范围.

班级，等级type(对象)
班级，等级type(名字，姓名, 碱基, 迪克特)
使用一个参数，返回对象。返回值是一个类型对象，通常与object.__class__.

这，这个，那，那个isinstance()建议使用内置函数来测试对象的类型，因为它考虑了子类。

使用三个参数，返回一个新的类型对象。这本质上是class声明。这，这个，那，那个名字，姓名字符串是类名，并成为__name__属性；属性碱基元组逐项化基类，并成为__bases__属性；以及迪克特字典是包含类主体定义的命名空间，并被复制到标准字典中，从而成为__dict__属性。例如，以下两个语句创建相同的type物体：

>>>
>>> class X:
...     a = 1
...
>>> X = type('X', (object,), dict(a=1))
另见类型对象.

在3.6版中更改：子类type不覆盖type.__new__可能不再使用单参数形式来获取对象的类型。

vars([对象])
返回__dict__属性的模块、类、实例或任何其他对象的__dict__属性。

对象(如模块和实例)具有可更新的__dict__属性；但是，其他对象可能对其__dict__属性(例如，类使用types.MappingProxyType以防止直接更新字典)。

没有争论，vars()表现得像locals()。注意，由于对局部变量字典的更新被忽略，因此局部变量字典只对读取有用。

zip(*可迭代性)
创建一个迭代器来聚合每个可迭代的元素。

返回元组的迭代器，其中i-第四个元组包含i-每个参数序列或可迭代项中的第四个元素。当最短的可迭代输入耗尽时，迭代器将停止。对于单个可迭代参数，它返回一个1元组的迭代器.如果没有参数，它将返回一个空迭代器。相当于：

def zip(*iterables):
    # zip('ABCD', 'xy') --> Ax By
    sentinel = object()
    iterators = [iter(it) for it in iterables]
    while iterators:
        result = []
        for it in iterators:
            elem = next(it, sentinel)
            if elem is sentinel:
                return
            result.append(elem)
        yield tuple(result)
保证了迭代的左向右求值顺序.这样，就可以使用以下方法将数据序列聚为n长度组的成语。zip(*[iter(s)]*n)。这重复了同迭代器n时间，以便每个输出元组都有以下结果：n调用迭代器。这有将输入分成n长块的效果.

zip()仅当您不关心更长的可迭代性中的尾随、不匹配值时，才应该使用不等长度的输入。如果这些值很重要，请使用itertools.zip_longest()相反。

zip()与*运算符可用于解压缩列表：

>>>
>>> x = [1, 2, 3]
>>> y = [4, 5, 6]
>>> zipped = zip(x, y)
>>> list(zipped)
[(1, 4), (2, 5), (3, 6)]
>>> x2, y2 = zip(*zip(x, y))
>>> x == list(x2) and y == list(y2)
True
__import__(名字，姓名, 全局=无, 当地人=无, from list=(), 级别=0)
注 这是一个在日常Python编程中不需要的高级函数，不像importlib.import_module().
此函数由import声明。它可以被替换(通过导入builtins模块和分配给builtins.__import__)以更改import语句，但这样做是强由于使用导入钩子通常更简单，因此不鼓励使用(请参见佩普302)以实现相同的目标，并且不会导致假定使用默认导入实现的代码出现问题。直接使用__import__()也不鼓励赞成importlib.import_module().

该函数导入模块。名字，姓名，可能使用给定的全球和本地人若要确定如何在包上下文中解释名称，请执行以下操作。这，这个，那，那个从列表提供应该从名字，姓名。标准实现不使用本地人参数，并使用全球类的包上下文。import声明。

水平指定是使用绝对导入还是使用相对导入。0(默认)意味着只执行绝对导入。正值水平指示要相对于模块调用的目录搜索的父目录数。__import__()(见佩普328有关详情)。

当名字，姓名变量的形式package.module，通常，返回顶级包(直到第一个点为止的名称)，不所命名的模块名字，姓名。然而，当一个非空从列表参数，则该模块命名为名字，姓名会被归还。

例如，语句import spam结果字节码类似于以下代码：

spam = __import__('spam', globals(), locals(), [], 0)
声明import spam.ham这一呼吁的结果是：

spam = __import__('spam.ham', globals(), locals(), [], 0)
注意__import__()返回toplevel模块，因为这是由import声明。

另一方面，声明from spam.ham import eggs, sausage as saus结果

_temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], 0)
eggs = _temp.eggs
saus = _temp.sausage
在这里，spam.ham模块从__import__()。从该对象中检索要导入的名称，并将其分配给各自的名称。

如果您只想按名称导入模块(可能在包中)，请使用importlib.import_module().

在3.3版中更改：负值水平不再支持(这也会将默认值更改为0)。

脚注

[1]	请注意，解析器只接受Unix样式的行结束约定。如果要从文件中读取代码，请确保使用换行符转换模式来转换Windows或Mac样式的换行符。